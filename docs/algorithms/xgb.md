# XGBoost

XGBoost（Extreme Gradient Boosting）是基于 Gradient Boosting 的高效实现，通过加法模型和前向分步算法构建多棵回归树。它引入正则化项和二阶近似，在精度和效率上都有显著提升。

## 数学模型

XGBoost 的预测函数是 $K$ 棵树的加权和：

$$ \hat{y}_i = \sum_{k=1}^K f_k(x_i), \quad f_k \in \mathcal{F} $$

其中 $\mathcal{F}$ 是回归树空间。优化目标为

$$ \min \sum_{i=1}^n L(y_i, \hat{y}_i) + \sum_{k=1}^K \Omega(f_k) $$

其中 $L$ 是损失函数，$\Omega(f) = \gamma T + \frac{1}{2}\lambda\|w\|^2$ 是正则化项，$T$ 是叶节点数，$w$ 是叶节点权重。

采用加法训练策略，第 $t$ 步的预测为 $\hat{y}_i^{(t)} = \hat{y}_i^{(t-1)} + f_t(x_i)$。对损失函数做二阶泰勒展开：

$$ \mathcal{L}^{(t)} \approx \sum_{i=1}^n \left[ g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i) \right] + \Omega(f_t) $$

其中 $g_i = \partial_{\hat{y}} L(y_i, \hat{y}_i^{(t-1)})$ 是一阶梯度，$h_i = \partial^2_{\hat{y}} L(y_i, \hat{y}_i^{(t-1)})$ 是二阶梯度。

对固定树结构，叶节点 $j$ 的最优权重为

$$ w_j^* = -\frac{\sum_{i \in I_j} g_i}{\sum_{i \in I_j} h_i + \lambda} $$

其中 $I_j$ 是分配到叶节点 $j$ 的样本集合。对应的目标函数值为

$$ \mathcal{L}^{(t)*} = -\frac{1}{2} \sum_{j=1}^T \frac{(\sum_{i \in I_j} g_i)^2}{\sum_{i \in I_j} h_i + \lambda} + \gamma T $$

## 模型假设

XGBoost 假设数据可被多棵树的加法模型有效拟合；梯度信息能够指导模型改进方向；二阶近似足够准确。对特征缩放不敏感，但对异常值和标签噪声较敏感。

## 模型特点

XGBoost 的优点在于预测精度高（业界最强模型之一）、支持多种损失函数、可处理缺失值、内置正则化防止过拟合、支持并行和分布式计算、提供特征重要性。其局限性是超参数较多需仔细调优、训练时间较长、可解释性较差、对大规模数据内存开销大。

## 正则化

XGBoost 的正则化项包含两项：

L1 正则 $\alpha \|w\|_1$ 促使叶节点权重稀疏，部分权重变为 0，类似 Lasso。

L2 正则 $\frac{1}{2}\lambda\|w\|^2$ 使权重整体缩小，类似 Ridge，同时改善数值稳定性。

树复杂度惩罚 $\gamma T$ 控制叶节点数量，较大的 $\gamma$ 促使树更简单，防止过拟合。

正则化参数 $\alpha, \lambda, \gamma$ 需通过交叉验证选择，默认值通常表现良好。

## 缺失值处理

XGBoost 对缺失值有专门处理机制。训练时对每个节点学习默认分裂方向（左或右），将缺失该特征的样本分配到默认方向。具体做法是尝试将缺失样本分配到左子节点和右子节点，选择使增益更大的方向。这一机制使模型能够自动学习缺失值的含义，无需预先填充。

## 求解策略

XGBoost 采用精确贪心算法或近似算法构建决策树。

精确贪心算法枚举所有可能的分裂点，选择使目标函数下降最大的分裂。增益计算为

$$ Gain = \frac{1}{2} \left[ \frac{G_L^2}{H_L + \lambda} + \frac{G_R^2}{H_R + \lambda} - \frac{(G_L+G_R)^2}{H_L+H_R+\lambda} \right] - \gamma $$

其中 $G_L, H_L$ 是左子节点的梯度和，$G_R, H_R$ 是右子节点的梯度和。若 $Gain > 0$ 则进行分裂。

近似算法（分位数算法）对连续特征用分位数近似候选分裂点，大幅减少计算量。可全局提分位数（所有树共享）或逐层提（每层重新计算）。

列采样和行采样可进一步加速并降低过拟合风险。`colsample_bytree` 控制每棵树的特征采样比例，`subsample` 控制样本采样比例。

训练可并行化（特征间）和分布式（特征分片），支持外存计算处理超出内存的数据。
